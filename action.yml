name: 'DNSLink Action'
description: 'Updates the DNSLink DNS record for a given domain'
branding:
  icon: 'box'
  color: 'blue'

inputs:
  cid:
    description: 'CID to update the DNSLink value to'
    required: true
  dnslink_domain:
    description: 'Domain to update the DNSLink for e.g. if you set docs.ipfs.tech, the _dnslink.docs.ipfs.tech TXT record will be updated'
    required: true
  cf_record_id:
    description: 'Cloudflare Record ID'
    required: false
  cf_zone_id:
    description: 'Cloudflare Zone ID'
    required: false
  cf_auth_token:
    description: 'Cloudflare API token'
    required: false
  dnsimple_token:
    description: 'DNSimple API token (account is auto-discovered)'
    required: false
  gandi_pat:
    description: 'GANDI Personal Authorization Token (Bearer auth)'
    required: false
  gandi_rrset_name:
    description: 'Name of the record in the dnslink_domain (i.e. "mysubdomain", _dnslink. will be prepended'
    required: false
  set_github_status:
    description: 'Set the GitHub commit status with the DNSLink domain and CID'
    default: 'false'
    required: false
  github_token:
    description: 'GitHub token'
    required: false

outputs:
  dnslink_domain:
    description: 'The domain that was updated'
    value: ${{ inputs.dnslink_domain }}
  dnslink_cid:
    description: 'The CID that was set'
    value: ${{ inputs.cid }}

runs:
  using: 'composite'
  steps:
    - name: Validate action inputs
      shell: bash
      run: |
        if [[ -z "${{ inputs.dnsimple_token }}" ]] && [[ -z "${{ inputs.cf_auth_token }}" || -z "${{ inputs.cf_zone_id }}" ]] && [[ -z "${{ inputs.gandi_pat }}" ]]; then
          echo "::error::DNSimple credentials (\`dnsimple_token\`), Cloudflare credentials (\`cf_auth_token\` and \`cf_zone_id\`), or Gandi credentials (\`gandi_pat\`) must be configured"
          exit 1
        fi

    - name: Set up Go
      if: inputs.dnsimple_token != ''
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'

    - name: Install dnslink-dnsimple
      if: inputs.dnsimple_token != ''
      shell: bash
      run: |
        go install github.com/ipfs/dnslink-dnsimple@v0.1.0

    - name: Update DNSLink in DNSimple
      if: inputs.dnsimple_token != ''
      shell: bash
      env:
        DNSIMPLE_TOKEN: ${{ inputs.dnsimple_token }}
        DNSLINK_DOMAIN: ${{ inputs.dnslink_domain }}
        DNSLINK_CID: ${{ inputs.cid }}
      run: |
        if [ -z "${DNSLINK_DOMAIN}" ]; then
          echo "Error: dnslink_domain is empty. Skipping DNSLink update."
          exit 1
        fi
        if [ -z "${DNSLINK_CID}" ]; then
          echo "Error: CID is empty. Skipping DNSLink update."
          exit 1
        fi

        echo "Updating DNSLink in DNSimple for: ${DNSLINK_DOMAIN}"
        dnslink-dnsimple \
          --domain "${DNSLINK_DOMAIN}" \
          --record "_dnslink" \
          --link "/ipfs/${DNSLINK_CID}"

    - name: Update DNSLink in Cloudflare
      if: inputs.cf_auth_token != ''
      shell: bash
      env:
        DNSLINK_DOMAIN: ${{ inputs.dnslink_domain }}
        DNSLINK_CID: ${{ inputs.cid }}
        CF_ZONE_ID: ${{ inputs.cf_zone_id }}
        CF_RECORD_ID: ${{ inputs.cf_record_id }}
        CF_AUTH_TOKEN: ${{ inputs.cf_auth_token }}
        GITHUB_REPO: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
      run: |
        set -euo pipefail

        if [ -z "${DNSLINK_DOMAIN}" ]; then
          echo "::error::dnslink_domain is empty"
          exit 1
        fi
        if [ -z "${DNSLINK_CID}" ]; then
          echo "::error::CID is empty"
          exit 1
        fi

        # Smart _dnslink. prefix handling
        if [[ "$DNSLINK_DOMAIN" == _dnslink.* ]]; then
          RECORD_NAME="$DNSLINK_DOMAIN"
        else
          RECORD_NAME="_dnslink.${DNSLINK_DOMAIN}"
        fi

        RECORD_CONTENT="\"dnslink=/ipfs/${DNSLINK_CID}\""
        CF_API="https://api.cloudflare.com/client/v4"

        # If record ID provided, use it directly (backward compatible)
        if [ -n "${CF_RECORD_ID:-}" ]; then
          echo "Using provided record ID: ${CF_RECORD_ID}"
          DISCOVERED_ID="${CF_RECORD_ID}"
        else
          echo "Discovering existing records for: ${RECORD_NAME}"

          # Query for existing TXT records with exact name match
          RESPONSE=$(curl -s --fail-with-body "${CF_API}/zones/${CF_ZONE_ID}/dns_records?type=TXT&name=${RECORD_NAME}" \
            -H "Authorization: Bearer ${CF_AUTH_TOKEN}" \
            -H "Content-Type: application/json")

          if [ "$(echo "$RESPONSE" | jq -r '.success')" != "true" ]; then
            echo "::error::Cloudflare API error: $(echo "$RESPONSE" | jq -r '.errors')"
            exit 1
          fi

          RECORD_COUNT=$(echo "$RESPONSE" | jq '.result | length')
          echo "Found ${RECORD_COUNT} existing record(s)"

          if [ "$RECORD_COUNT" -eq 0 ]; then
            DISCOVERED_ID=""
          elif [ "$RECORD_COUNT" -eq 1 ]; then
            DISCOVERED_ID=$(echo "$RESPONSE" | jq -r '.result[0].id')
            echo "Discovered record ID: ${DISCOVERED_ID}"
          else
            echo "::error::Found ${RECORD_COUNT} TXT records for ${RECORD_NAME}. Please manually remove duplicates in Cloudflare dashboard and re-run."
            exit 1
          fi
        fi

        # Create or Update the record
        RECORD_DATA=$(jq -n \
          --arg type "TXT" \
          --arg name "$RECORD_NAME" \
          --arg content "$RECORD_CONTENT" \
          --arg comment "${GITHUB_REPO}/${GITHUB_SHA}" \
          '{type: $type, name: $name, content: $content, comment: $comment}')

        if [ -z "${DISCOVERED_ID:-}" ]; then
          echo "Creating new DNS record..."
          RESULT=$(curl -s --fail-with-body -X POST "${CF_API}/zones/${CF_ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CF_AUTH_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$RECORD_DATA")
        else
          echo "Updating existing DNS record..."
          RESULT=$(curl -s --fail-with-body -X PUT "${CF_API}/zones/${CF_ZONE_ID}/dns_records/${DISCOVERED_ID}" \
            -H "Authorization: Bearer ${CF_AUTH_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$RECORD_DATA")
        fi

        if [ "$(echo "$RESULT" | jq -r '.success')" != "true" ]; then
          echo "::error::Failed to create/update record: $(echo "$RESULT" | jq -r '.errors')"
          exit 1
        fi

        FINAL_ID=$(echo "$RESULT" | jq -r '.result.id')
        echo "DNSLink updated: ${RECORD_NAME} -> ${RECORD_CONTENT}"
        echo "Record ID: ${FINAL_ID}"

    - name: Update DNSLink in Gandi
      if: inputs.gandi_pat != ''
      shell: bash
      env:
        DNSLINK_DOMAIN: ${{ inputs.dnslink_domain }}
        DNSLINK_CID: ${{ inputs.cid }}
        GANDI_PAT: ${{ inputs.gandi_pat }}
        GANDI_RRSET_NAME: ${{ inputs.gandi_rrset_name }}
      run: |
        if [ -z "${DNSLINK_DOMAIN}" ]; then
          echo "Error: dnslink_domain is empty. Skipping DNSLink update."
          exit 1
        fi
        if [ -z "${DNSLINK_CID}" ]; then
          echo "Error: CID is empty. Skipping DNSLink update."
          exit 1
        fi

        echo "Updating DNSLink in Gandi for: ${DNSLINK_DOMAIN}"
        echo "TTL set to minimum: 300s"
        curl -X PUT \
          -H 'content-type: application/json' \
          -d "{\"rrset_values\":[\"dnslink=/ipfs/${DNSLINK_CID}\"],\"rrset_ttl\":300}" \
          -H "Authorization: Bearer ${GANDI_PAT}" \
          "https://api.gandi.net/v5/livedns/domains/${DNSLINK_DOMAIN}/records/_dnslink.${GANDI_RRSET_NAME}/TXT"

    - name: Set GitHub commit status
      if: ${{ inputs.set_github_status }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const cid = '${{ inputs.cid }}';

          // Determine the correct SHA based on the event type
          let sha;
          if (context.eventName === 'workflow_run') {
            // For workflow_run events triggered by PRs, use the PR's head SHA
            sha = context.payload.workflow_run.head_sha;
          } else if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
            // For PR events, use the head SHA
            sha = context.payload.pull_request.head.sha;
          } else {
            // For push events, use the commit SHA
            sha = context.sha;
          }

          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: sha,
            state: 'success',
            description: `${{ inputs.dnslink_domain }} -> ${{ inputs.cid }}`,
            context: 'DNSLink'
          });
